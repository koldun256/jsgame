<!DOCTYPE html>
<html>
    <head>
        <link rel="icon" href="/i.ico" />
    </head>
    <body>
        <canvas id="canvas" style="border: 2px solid black"></canvas>
        <script src="/socket.io/socket.io.js"></script>
        <script src="https://code.jquery.com/jquery-1.11.1.js"></script>
        <script>
            const mapSize = [80,80];
            let baseSize;
            const baseColor = "#000000";
            let basesPositions;
            function calcPosOnScreen(){
                if(me.position[0]<(0.5*screenWidth)){
                    screenCenter[0] = screenWidth*0.5;
                    positionOnScreen[0] = me.position[0];
                }else if(me.position[0] > width - (0.5*screenWidth)){
                    screenCenter[0] = width-(screenWidth*0.5);
                    positionOnScreen[0] = screenWidth+me.position[0]-width;
                }else {
                    screenCenter[0] = me.position[0];
                    positionOnScreen[0] = 0.5*screenWidth;
                }

                if(me.position[1]<(0.5*screenHeight)){
                    screenCenter[1] = screenHeight*0.5;
                    positionOnScreen[1] = me.position[1];
                }else if(me.position[1]>height-(0.5*screenHeight)){
                    screenCenter[1] = height-(screenHeight*0.5);
                    positionOnScreen[1] = screenHeight+me.position[1]-height;
                }else {
                    screenCenter[1] = me.position[1];
                    positionOnScreen[1] = 0.5*screenHeight;
                }
            }
            function drawMap(){
                ctx.lineWidth = 2;
                ctx.strokeStyle = "black";
                ctx.clearRect(screenWidth-(mapSize[0]+10),10,mapSize[0],mapSize[1]);
                ctx.strokeRect(screenWidth-(mapSize[0]+10),10,mapSize[0],mapSize[1]);
                ctx.fillStyle = me.color;
                ctx.fillRect(   screenWidth-(mapSize[0]+10)+(me.position[0]/width*mapSize[0]),
                                10+(me.position[1]/height*mapSize[1]),
                                4,4);
            }
            function drawTarget(globalPosition){
                let x = globalPosition.x-screenCenter[0] + (screenWidth/2);
                let y = globalPosition.y-screenCenter[1] + (screenHeight/2);
                ctx.beginPath();
                ctx.arc(x, y, 15, 0, 2 * Math.PI, false);
                ctx.lineWidth = 7;
                ctx.strokeStyle = "red";
                ctx.stroke();
            }
            let manaIndicatorSetting = {
                offsets: [10,10],
                size: [300,30],
                colors: {
                    active: "#40b0c7",
                    notActive: "#30899c"
                }
            };
            let maxMana;
            let speed;
            let manaZonesSetting;
            let screenCenter = [0,0];
            let loopID;
            var socket = io();
            var blockHeight = 30;
            var blockWidth = 30;
            let ctx = document.getElementById("canvas").getContext("2d");
            let state = 0;
            let screenWidth;
            let screenHeight;
            let width;
            let height;
            let others = {};
            let me = {};
            let positionOnScreen = [0,0];
            let isMouseDown = false;
            function Movement(user,point){
                let player = user;
                
                function calcDelta(point){
                    if(point.x == user.position[0]){
                        return [0,speed];
                    }else if(point.y == user.position[1]){
                        return [speed,0];
                    }else{
                        let allXDelta = point.x - user.position[0];
                        let allYDelta = point.y - user.position[1];
                        let dx;
                        let dy;
                        let a = allXDelta/allYDelta;
                        if(a < 0){
                            dx = Math.abs(speed*a/(a-1)) * (Math.abs(allXDelta)/allXDelta);
                            dy = Math.abs(speed/(a-1)) * (Math.abs(allYDelta)/allYDelta);
                        }else {
                            dx = Math.abs(speed*a/(a+1)) * (Math.abs(allXDelta)/allXDelta);
                            dy = Math.abs(speed/(a+1)) * (Math.abs(allYDelta)/allYDelta);
                        }
                        return [dx,dy];
                    }
                }
                function calcDirection(){
                    let a = !(player.position[0] > point.x); //true - right, false - left
                    let b = !(player.position[1] > point.y); //true - down , false - up
                    return [a,b]; 
                }
                function isFinished(){
                    if(direction[0]){
                        if(direction[1]){
                            return player.position[0] > point.x && player.position[1] > point.y;
                        }else{
                            return player.position[0] > point.x && player.position[1] < point.y;
                        }
                    }else {
                        if(direction[1]){
                            return player.position[0] < point.x && player.position[1] > point.y;
                        }else{
                            return player.position[0] < point.x && player.position[1] < point.y;
                        }
                    }
                    return false;
                }
                let direction = calcDirection();
                this.target = point;
                this.d = calcDelta(point);
                this.speed = user.speed;
                
                this.setTarget = function(newTarget){
                    this.target = newTarget;
                    this.d = calcDelta(newTarget);
                }
                this.move = function(){
                    player.position[0]+=this.d[0];
                    player.position[1]+=this.d[1];
                    if(isFinished()){
                        delete player.movement;
                    }
                };
            }
            function isPlayerInManaZone(playerPos,basePos){
                function calcDistance(pointA,pointB){
                    return Math.abs(Math.sqrt((pointA[0]-pointB[0])**2 + (pointA[1]-pointB[1])**2));
                }
                let distance = calcDistance(playerPos,basePos);
                let result = (distance > (manaZonesSetting.distance/2 - manaZonesSetting.width/2)) && (distance < (manaZonesSetting.distance/2 + manaZonesSetting.width/2));
                return result;
            }
            function debounce(f,ms){
                let isCooldown = false;
                return function() {
                    if (isCooldown) return;
                    f.apply(this, arguments);
                    isCooldown = true;
                    setTimeout(() => isCooldown = false, ms);
                };
            }
            function localToGlobalCoords(x,y){
                return [x+screenCenter[0]-screenWidth/2,y+screenCenter[1]-screenHeight/2];
            }
            let addTarget = function(x,y){
                socket.emit("setTarget",{x:x,y:y});
            };
            addTarget = debounce(addTarget,100);
            socket.on("update data",function(msg){
                console.log("updating data: ");
                console.log(msg.me.position);
                me.position = msg.me.position;
                me.mana = msg.me.mana;
                if("movement" in msg.me){
                    me.movement = new Movement(me,msg.me.movement.target);
                }else{
                    delete me.movement;
                }
                for(let key in others){
                    if(key in msg){
                        others[key].position = msg[key].position;
                        if("movement" in msg[key]){
                            others[key].movement = new Movement(others[key],msg[key].movement.target);
                        }else {
                            delete others[key].movement;
                        }
                    }
                }
            });
            socket.on("setsize",function(msg){
                speed = msg.speed;
                $("#canvas").attr("height",msg.height+"px");
                $("#canvas").attr("width",msg.width+"px");
                ctx = document.getElementById("canvas").getContext("2d");
                screenWidth = msg.width;
                screenHeight = msg.height;
                width = msg.fieldWidth;
                height = msg.fieldHeight;
                baseSize = msg.baseSize;
                $("#canvas").click(function(){
                    if(state==0) socket.emit("started");
                });
            });
            window.addEventListener("load",function(){
                    
                let bg = new Image();
                bg.src = "graphic\\bg.png";
                bg.addEventListener("load",function(){
                    ctx.font = "20px serif";
                    ctx.fillText("Нажмите на это что бы начать", 10, 50);
                    socket.on("get target",function(msg){
                        console.log("movement");
                        if(msg.id == me.id){
                            me.postion = msg.currentPosition;
                            me.movement = new Movement(me,msg.target);
                            return;
                        }
                        if(msg.id in others){
                            others[msg.id].position = msg.currentPosition;
                            others[msg.id].movement = new Movement(others[msg.id],msg.target);
                        }
                    });
                    $("#canvas").mousedown(function(a){
                        isMouseDown = true;
                        if(state!=2) return;
                        addTarget(...localToGlobalCoords(a.clientX,a.clientY));
                    });
                    $("#canvas").mouseup(function(){
                        isMouseDown = false;
                    });
                    $("#canvas").mousemove(function(a){
                        if(state!=2) return;
                        if(isMouseDown) addTarget(...localToGlobalCoords(a.clientX,a.clientY));
                    });
                    socket.on("wait",function(){
                        clear();
                        ctx.fillText("Ждите", 10, 50);
                        state = 1;
                    });
                    socket.on("start",function(msg){
                        others = msg.others;
                        me = msg.me;
                        basesPositions = msg.basesPositions;
                        me.isInManaZone = false;
                        manaZonesSetting = msg.manaRegenZone;
                        maxMana = msg.maxMana;
                        calcPosOnScreen();
                        loopID = setInterval(function(){
                            if("movement" in me){
                                me.movement.move();
                                calcPosOnScreen();
                            }
                            me.isInManaZone = false;
                            basesPositions.forEach(base=>{
                                if(isPlayerInManaZone(me.position,base)){
                                    me.isInManaZone = true;
                                }
                            });
                            if(me.isInManaZone){
                                me.mana += manaZonesSetting.regen;
                                if(me.mana > maxMana){
                                    me.mana = maxMana;
                                }
                            }
                            for(let key in others){
                                if("movement" in others[key]){
                                    others[key].movement.move();
                                }   
                            }

                            updateImage(bg);
                        },100);
                        state = 2;
                    });
                    socket.on("removeMovement",id=>{
                        if(id==me.id){
                            if("movement" in me){
                                delete me.movement;
                            }
                        }else {
                            for(let key in others){
                                if("movement" in others[key]) delete others[key].movement;
                            }
                        }
                    });
                    socket.on("set position",function(msg){
                        for(let key in others){
                            if(others[key].id==msg.id) others[key].position = msg.position
                        }
                    });
                },false);
            },false);
            
            function clear(){
                ctx.clearRect(0, 0, document.getElementById("canvas").width, document.getElementById("canvas").height);
            }
            function drawBlock(x,y,color){
                ctx.fillStyle = color;
                ctx.fillRect(x,y,blockWidth,blockHeight);
            }
            function drawManaIndicator(){
                ctx.fillStyle = "white"
                ctx.fillRect(...manaIndicatorSetting.offsets,...manaIndicatorSetting.size);
                ctx.fillStyle = manaIndicatorSetting.colors[me.isInManaZone?"active":"notActive"];
                ctx.fillRect(...manaIndicatorSetting.offsets,me.mana/maxMana*manaIndicatorSetting.size[0],manaIndicatorSetting.size[1]);
                ctx.strokeStyle = "black";
                ctx.lineWidth = 2;
                ctx.strokeRect(...manaIndicatorSetting.offsets,...manaIndicatorSetting.size);
            }
            function drawBases(){
                basesPositions.forEach(basePosition => {
                    ctx.globalAlpha = 0.5;
                    ctx.fillStyle = baseColor;
                    ctx.fillRect(   basePosition[0] - screenCenter[0] + screenWidth/2 -baseSize/2,
                                    basePosition[1] - screenCenter[1] + screenHeight/2 -baseSize/2,
                                    baseSize,baseSize);
                    ctx.globalAlpha = 1;
                });
            }
            function drawManaZones(){
                basesPositions.forEach(zoneCenter=>{
                    
                    ctx.beginPath();
                    ctx.arc(zoneCenter[0] - screenCenter[0] + screenWidth/2,
                            zoneCenter[1] - screenCenter[1] + screenHeight/2,
                            manaZonesSetting.distance/2, 0, 2 * Math.PI, false);
                    ctx.globalAlpha = 0.5;
                    ctx.lineWidth = manaZonesSetting.width;
                    ctx.strokeStyle = "#599ede";
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                });
            }
            function drawPlayer(player){
                if(!("position" in player)) return;
                drawBlock(player.position[0] - screenCenter[0] + (screenWidth)/2 - blockWidth/2,
                    player.position[1] - screenCenter[1] + (screenHeight/2) - blockHeight/2,
                    player.color);
            }
            function updateImage(bg){
                clear();
                ctx.drawImage(bg,screenCenter[0]-(screenWidth/2),screenCenter[1]-(screenHeight/2),screenWidth,screenHeight,0,0,screenWidth,screenHeight);
                if("movement" in me) drawTarget(me.movement.target);
                drawPlayer(me);
                for(let key in others){
                    drawPlayer(others[key]);
                }
                drawBases();
                drawManaZones();
                //drawPlayer(other);
                drawMap();
                drawManaIndicator();
            }
        </script>
    </body>
</html>